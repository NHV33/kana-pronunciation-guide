hebonTransliteration = ['a', 'i', 'u', 'e', 'o', 'ka', 'ki', 'ku', 'ke', 'ko', 'kya', 'kyi', 'kyu', 'kye', 'kyo', 'ga', 'gi', 'gu', 'ge', 'go', 'gya', 'gyi', 'gyu', 'gye', 'gyo', 'sa', 'shi', 'su', 'se', 'so', 'sha', 'shi', 'shu', 'she', 'sho', 'za', 'ji', 'zu', 'ze', 'zo', 'ja', 'ji', 'ju', 'je', 'jo', 'ta', 'chi', 'tsu', 'te', 'to', 'cha', 'chi', 'chu', 'che', 'cho', 'da', 'ji', 'zu', 'de', 'do', 'dya', 'dyi', 'dyu', 'dye', 'dyo', 'na', 'ni', 'nu', 'ne', 'no', 'nya', 'nyi', 'nyu', 'nye', 'nyo', 'ha', 'hi', 'fu', 'he', 'ho', 'hya', 'hyi', 'hyu', 'hye', 'hyo', 'ba', 'bi', 'bu', 'be', 'bo', 'bya', 'byi', 'byu', 'bye', 'byo', 'pa', 'pi', 'pu', 'pe', 'po', 'pya', 'pyi', 'pyu', 'pye', 'pyo', 'ma', 'mi', 'mu', 'me', 'mo', 'mya', 'myi', 'myu', 'mye', 'myo', 'ya', 'yu', 'yo', 'ra', 'ri', 'ru', 're', 'ro', 'rya', 'ryi', 'ryu', 'rye', 'ryo', 'wa', 'i', 'e', 'o', 'vu', 'n'];
hiraganaCombinations = ['あ', 'い', 'う', 'え', 'お', 'か', 'き', 'く', 'け', 'こ', 'きゃ', 'きぃ', 'きゅ', 'きぇ', 'きょ', 'が', 'ぎ', 'ぐ', 'げ', 'ご', 'ぎゃ', 'ぎぃ', 'ぎゅ', 'ぎぇ', 'ぎょ', 'さ', 'し', 'す', 'せ', 'そ', 'しゃ', 'しぃ', 'しゅ', 'しぇ', 'しょ', 'ざ', 'じ', 'ず', 'ぜ', 'ぞ', 'じゃ', 'じぃ', 'じゅ', 'じぇ', 'じょ', 'た', 'ち', 'つ', 'て', 'と', 'ちゃ', 'ちぃ', 'ちゅ', 'ちぇ', 'ちょ', 'だ', 'ぢ', 'づ', 'で', 'ど', 'ぢゃ', 'ぢぃ', 'ぢゅ', 'ぢぇ', 'ぢょ', 'な', 'に', 'ぬ', 'ね', 'の', 'にゃ', 'にぃ', 'にゅ', 'にぇ', 'にょ', 'は', 'ひ', 'ふ', 'へ', 'ほ', 'ひゃ', 'ひぃ', 'ひゅ', 'ひぇ', 'ひょ', 'ば', 'び', 'ぶ', 'べ', 'ぼ', 'びゃ', 'びぃ', 'びゅ', 'びぇ', 'びょ', 'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ', 'ぴゃ', 'ぴぃ', 'ぴゅ', 'ぴぇ', 'ぴょ', 'ま', 'み', 'む', 'め', 'も', 'みゃ', 'みぃ', 'みゅ', 'みぇ', 'みょ', 'や', 'ゆ', 'よ', 'ら', 'り', 'る', 'れ', 'ろ', 'りゃ', 'りぃ', 'りゅ', 'りぇ', 'りょ', 'わ', 'ゐ', 'ゑ', 'を', 'ゔ', 'ん'];
hiragana = ['ぁ','あ','ぃ','い','ぅ','う','ぇ','え','ぉ','お','か','が','き','ぎ','く','ぐ','け','げ','こ','ご','さ','ざ','し','じ','す','ず','せ','ぜ','そ','ぞ','た','だ','ち','ぢ','っ','つ','づ','て','で','と','ど','な','に','ぬ','ね','の','は','ば','ぱ','ひ','び','ぴ','ふ','ぶ','ぷ','へ','べ','ぺ','ほ','ぼ','ぽ','ま','み','む','め','も','ゃ','や','ゅ','ゆ','ょ','よ','ら','り','る','れ','ろ','ゎ','わ','ゐ','ゑ','を','ん','ゔ'];
katakana = ['ァ','ア','ィ','イ','ゥ','ウ','ェ','エ','ォ','オ','カ','ガ','キ','ギ','ク','グ','ケ','ゲ','コ','ゴ','サ','ザ','シ','ジ','ス','ズ','セ','ゼ','ソ','ゾ','タ','ダ','チ','ヂ','ッ','ツ','ヅ','テ','デ','ト','ド','ナ','ニ','ヌ','ネ','ノ','ハ','バ','パ','ヒ','ビ','ピ','フ','ブ','プ','ヘ','ベ','ペ','ホ','ボ','ポ','マ','ミ','ム','メ','モ','ャ','ヤ','ュ','ユ','ョ','ヨ','ラ','リ','ル','レ','ロ','ヮ','ワ','ヰ','ヱ','ヲ','ン','ヴ'];

const tiny_hira = ['ぁ', 'ぃ', 'ぅ', 'ぇ', 'ぉ', 'っ', 'ゃ', 'ゅ', 'ょ', 'ゎ'];
const tiny_kata = ['ァ', 'ィ', 'ゥ', 'ェ', 'ォ', 'ッ', 'ャ', 'ュ', 'ョ', 'ヮ'];
const all_tiny_kana = tiny_hira.concat(tiny_kata);
// っッ
// ぁ-ゖァ-ヺ all kana glyphs
// ぁ-ぢつ-ゔァ-ヂツ-ヴ <== no little tsu
// const tsuPattern = /[っッ]{1}[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1}/;
// const doubleKanaPattern = /[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1}[ぁぃぅぇぉゃゅょァィゥェォャュョ]{1}/;
// const singleKanaPattern = /^([ぁ-ぢつ-ゔァ-ヂツ-ヴ]){1}|([ぁ-ぢつ-ゔァ-ヂツ-ヴ]){1}$|[^>]{1}([ぁ-ぢつ-ゔァ-ヂツ-ヴ]){1}/;
// const singleKanaPattern = /([^っッ]?)(\[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1})/;
const singleKanaPattern = /[っッ]{1}[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1}|[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1}[ぁぃぅぇぉゃゅょァィゥェォャュョ]{1}|[ぁ-ぢつ-ゔァ-ヂツ-ヴ]{1}/;

const getMatchingItem = (item, list1, list2) => { return list1.includes(item) ? list2[list1.indexOf(item)] : item; };

function replaceAtIndex(str, index, length, newSubstring) {
  if (index < 0 || index >= str.length) { return str; }
  const stringWithoutChar = str.substring(0, index) + str.substring(index + length);

  return stringWithoutChar.substring(0, index) + newSubstring + stringWithoutChar.substring(index);
}

function getMatchIndexes(str, regex) {
  const indexes = [];
  let match;
  const regexWithGlobal = new RegExp(regex, 'g'); // Ensure the regex has the global flag set

  while ((match = regexWithGlobal.exec(str)) !== null) {
      indexes.push(match.index); // Store the index of the match
  }

  return indexes;
}

// function wrapAllMatchingChars(text, regex_pattern, start_tag, end_tag) {
//   const matchIndexes = getMatchIndexes(text, regex_pattern)
//   for (let i = matchIndexes.length - 1; i >=0 ; i -= 1) {
//     const matchIndex = matchIndexes[i];
//     const matchChar = text[matchIndex];
//     const replacement = start_tag + matchChar + end_tag;
//     text = replaceAtIndex(text, matchIndex, replacement);
//   }

//   return text;
// }

// function addTagsToNodeText(node, regex_pattern, start_tag, end_tag) {
//   if (node.nodeType !== Node.ELEMENT_NODE || node.childNodes.length < 1) { return; }
//   const nodeText = node.childNodes[0].nodeValue;
//   const taggedString = wrapAllMatchingChars(nodeText, regex_pattern, start_tag, end_tag);
//   node.innerHTML = node.innerHTML.replace(nodeText, taggedString);
// }

function getMatches(str, regex) {
  const matches = [];
  let match;
  const regexWithGlobal = new RegExp(regex, 'g'); // Ensure the regex has the global flag set

  while ((match = regexWithGlobal.exec(str)) !== null) {
    matches.push(match);
  }

  return matches;
}

function nextCharTiny(text, matchIndex) {
  return matchIndex < text.length - 2 && all_tiny_kana.includes(text[matchIndex + 1])
}

function kata2hira(text) {
  const hira = []
  text.split("").forEach(ch => {
    hira.push(getMatchingItem(ch, katakana, hiragana))
  });
  return hira.join("")
}

function wrapAllMatchingChars(text, regex_pattern) {
  const matches = getMatches(text, regex_pattern)

  for (let i = matches.length - 1; i >= 0; i -= 1) {
    const matchObj = matches[i]
    const matchObjLastIndex = matchObj.length - 1;
    const matchString = matchObj[matchObjLastIndex];
    const fullMatch = matchObj[0]
    // const offSet = fullMatch.indexOf(matchString);
    const matchIndex = matchObj.index;
    const matchLength = matchString.length;

  console.log(matchIndex, matchObjLastIndex, matchString, matchLength)
    // const matchString = text.substring(matchIndex, matchIndex + matchLength);

    console.log(matches[i])

    // let hiraString = matchString;
    // if(/[ァ-ヺ]/.test(matchString)) {
    //   hiraString = kata2hira(matchString);
    // }

    let hiraString = kata2hira(matchString);

    let romaji = getMatchingItem(hiraString, hiraganaCombinations, hebonTransliteration);

    if(hiraString.length > 1 && hiraString.includes("っ")) {
      console.log("test")
      const nonTsu = getMatchingItem(hiraString[1], hiraganaCombinations, hebonTransliteration);
      romaji = nonTsu[0] + nonTsu;

    }

    const replacement = `<ruby>${matchString}<rt>${romaji}</rt></ruby>`;

    text = replaceAtIndex(text, matchIndex, matchLength, replacement);
  }

  return text;
}

function addTagsToNodeText(node, regex_patterns) {
  if (node.nodeType !== Node.ELEMENT_NODE || node.childNodes.length < 1) { return; }
  const nodeText = node.childNodes[0].nodeValue;
  let taggedString = nodeText;
  regex_patterns.forEach(pattern => {
    taggedString = wrapAllMatchingChars(taggedString, pattern);
  });
  node.innerHTML = node.innerHTML.replace(nodeText, taggedString);
}

function checkChildren(node) {

  const childNodes = node.childNodes;

  for (let i = 0; i < childNodes.length; i++) {
    const childNode = childNodes[i];
    checkChildren(childNode);
  }

  // addTagsToNodeText(node, tsuPattern);
  // addTagsToNodeText(node, [tsuPattern, doubleKanaPattern, singleKanaPattern]);
  addTagsToNodeText(node, [singleKanaPattern]);
}


checkChildren(document.body);


// NOTE: need to add lookup/conversion for all the tiny vowel combinations:
// Fa Fi Wi We Ti, etc.
